Модульность
1 тии модульности - расширение свойств обьекта - Шаблон пространста имен

var MYAPP = {
    modules : {
        css : {}
    }
}

функция namespace
MYAPP.namespace('MYAPP.modules.css'); // еквивалентно if (MYAPP.modules) { MYAPP,modules.css = {} }

MYAPP.namespace = function (ns_string) {
    var parts = ns_string.split('.'),
        parent = MYAPP,
        i;

    // отбросить начальный префикс - имя глобального объекта
    if (partsfO] === "MYAPP") {
        parts = parts.slice(1);
    }
    for (i = 0; i < parts.length; i += 1) {
        // создать свойство, если оно отсутствует
        if (typeof parent[parts[i]] === "undefined") {
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }
    return parent;
};

Такая реализация делает допустимыми все следующие варианты
использования функции:
// присваивать возвращаемое значение локальной переменной
var module2 = MYAPP.namespaceCMYAPP.modules.module2');
module2 === MYAPP.modules.module2; // true
// опускать начальный префикс 'MYAPP'
MYAPP.namespace('modules.module51');

MYAPP.namespace('modules.css') = (function (MYAPP, window) {
    // зависимости
    var event = MYAPP.modules.Event,
        dom = MYAPP.modules.Dom;

    // остальная часть функции
    // использует переменные event и dom...

    return {
        getStyle : function(){},
        setStyle : function(){}
    }

})(MYAPP, this);

Почему так нужно делать ?

2. Модульность с использованием изолированного простарнста имен

В шаблоне пространства имен имеется единственный глобальный
объект; в шаблоне изолированного пространства имен единственным
глобальным объектом является конструктор: назовем его Sandbox(). Этот
конструктор используется для создания объектов пространств имен
и принимает функцию обратного вызова, которая будет играть роль
изолированного окружения для вашего программного кода.

Sandbox(['ajax', 'event'], function (box) {
    console.log(box);
});

SandboxC ajax', 'dom'. function (box) {
    console.log(box);
});

Sandbox('*', function (box) {
    console.log(box);
});

Sandbox(function (box) {
    console.log(box);
});

Объект box - это аналог объекта MYAPP в шаблоне пространства имен;
он должен включать все библиотеки, необходимые для работы вашего
программного кода.

И еще один пример использования шаблона, иллюстрирующий
возможность создания нескольких экземпляров объекта изолированного
пространства имен; вы можете даже вкладывать их друг в друга, не
вызывая конфликтов между ними:

Sandbox('dom', 'event', function (box) {
    // использует модули dom и event
    Sandbox('ajax', function (box) {
        // другой обьект "box" изолированного пространства имен
        // этот обьект "box" отличается от объекта
        // "box", находящегося за пределами этой функции
        // конец пространства имен, использующего модуль Ajax
    });
    // здесь модуль Ajax недоступен
});


Как видно из этих примеров, используя шаблон изолированного
пространства имен, можно защитить глобальное пространство имен,
обернув свой программный код функцией обратного вызова.


Реализация


А. Реализация добавления модулей

Спросить про статические члены функции

Sandbox.modules = {};

Sandbox.modules.dom = function (box) {
    box.getElement = function () {};
    box.getStyle = function () {};
    box.foo = "bar";
};

Sandbox.modules.event = function (box) {
    // при необходимости к прототипу Sandbox можно обратиться так:
    // box.constructor.prototype.m = "mmm";
    box.attachEvent = function () {};
    box.detachEvent = function () {>;
};

Sandbox.modules.ajax = function (box) {
    box.makeRequest = function () {};
    box.getResponse = function () {};
};

Б. Реализация Констуктора

Спросить как это работает - (расширяетс ссылка this)

function Sandbox() {
    // преобразовать аргументы в массив
    var args = Array.prototype.slice.call(arguments),
        // последний аргумент - функция обратного вызова
        callback = args.pop(),
        // имена модулей могут передаваться в форме массива
        // или в виде отдельных параметров
        modules = (args[0] && typeof args[0] === "string") ? args : args[0],
        i;

    // проверить, была ли функция вызвана
    // как конструктор
    if (!(this instanceof Sandbox)) {
        return new Sandbox(modules, callback);
    }

    // добавить свойства к объекту 'this', если это необходимо:
    this.а = 1;
    this.о = 2;
    // добавить модули в базовый объект 'this'
    // отсутствие аргументов с именами модулей или аргумент со значением "*"
    // предполагает необходимость включения "всех модулей"
    if (!modules || modules === '*') {
        modules = [];
        for (i in Sandbox.modules) {
            if (Sandbox.modules.hasOwnProperty(i)) {
                modules.push(i);
            }
        }
    }
    // инициализировать необходимые модули
    for (i =0; i < modules.length; i += 1) {
        Sandbox.modules[modules[i]](this);
    }
    // вызвать функцию обратного вызова
    callback(this);
}

// добавить свойства к прототипу, если это необходимо
Sandbox.prototype = {
    name: "My Application",
    version: "1.0",
    getName: function () {
        return this.name;
    }
};

* Проверка того, указывает ли ссылка this на экземпляр Sandbox, и если
нет (когда функция SandboxQ вызывается без оператора new), то
вызвать функцию как конструктор.
• Внутри конструктора допускается добавлять новые свойства к
объекту this. Точно так же допускается добавлять свойства к прототипу
конструктора.
• Информация о необходимых модулях может передаваться в виде
массива имен, в виде отдельных аргументов или в виде аргумента
со значением '*' (это значение используется по умолчанию в случае
отсутствия аргумента), означающего, что необходимо включить все
имеющиеся модули. Обратите внимание, что в данном примере
реализации мы не беспокоимся о загрузке необходимых модулей,
находящихся в отдельных файлах, но такую возможность необходимо
предусмотреть. Она поддерживается, например, библиотекой YUI3.
Вы можете загрузить только основной модуль (известный также как
«запускающий»), а все остальные модули будут загружаться из
файлов, имена которых следуют соглашению, что имена файлов
соответствуют именам модулей.
• Определившись с перечнем необходимых модулей, мы
инициализируем их, то есть вызываем функции, реализующие модули.
• Последний аргумент конструктора - функция обратного вызова. Эта
функция вызывается сразу после создания нового экземпляра
объекта. Она играет роль изолированного пространства имен и
получает объект box, заполненный всей необходимой функциональностью.


ДЗ.
1. напистаь функцию Sandbox.add(callback, obj);

чтобы можно было создавать модуль таким способом

Sandbox.add('css', function(box) {

    box.setStyle = function() {
        box.dom.getEl(); // можно работать с модулями указанные в зависимостях
        box.ajax.send();
    }

}, {
    require : 'ajax', 'dom'
});

2. на основе всех прошлых домашних работ создать Sandbox модули

css, utils, dom, animate и подобные в случае необходимости
и показать пример использования

Sandbox('css', 'utils', 'dom', 'animate', function(box) {
    box.css.getStyle();
    box.dom.createEl();
    box.animate.go(); // тоесть пример использования
});
